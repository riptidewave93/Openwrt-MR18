--- a/drivers/mtd/nand/ath79_nand.c
+++ b/drivers/mtd/nand/ath79_nand.c
@@ -0,0 +1,352 @@
+/*
+ * NAND Chip driver for Atheros on-chip NAND Flash Controller
+ *
+ * Copyright (C) 2012 Meraki Inc <jdizzle@meraki.net>
+ */
+#include <linux/module.h>
+#include <linux/types.h>
+#include <linux/init.h>
+#include <linux/kernel.h>
+#include <linux/string.h>
+#include <linux/ioport.h>
+#include <linux/platform_device.h>
+#include <linux/delay.h>
+#include <linux/err.h>
+#include <linux/slab.h>
+#include <linux/io.h>
+#include <linux/bitops.h>
+#include <linux/jiffies.h>
+
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/nand.h>
+#include <linux/mtd/nand_ecc.h>
+#include <linux/mtd/partitions.h>
+
+#include <asm/mach-ath79/ath79.h>
+#include <asm/mach-ath79/ath79_nand_regs.h>
+#include <asm/mach-ath79/nand.h>
+#include <linux/spi/flash.h>
+
+#define DRV_NAME	"ath79-nand"
+#define DRV_VERSION	"0.1"
+#define DRV_AUTHOR	"Meraki"
+#define DRV_DESC	"Atheros on-chip NAND Flash Controller Driver"
+
+#define TIMEOUT_LOOP(condition, name, ...) do {   \
+		int _timeout = 0;		  \
+		while (_timeout++ < 1000 && (condition))	\
+			udelay(1);				\
+		if (_timeout >= 1000)					\
+			printk(DRV_NAME ": " name ": TIMEOUT EXCEEDED!!\n" __VA_ARGS__); \
+	} while (0)
+
+struct ath79_nand {
+	void __iomem *controller;
+	uint32_t fifo_buf;
+	uint32_t fifo_buf_count;
+
+	struct mtd_info mtd;
+	struct mtd_partition *mtd_parts;
+	struct nand_chip chip;
+};
+
+static int ath79_nand_chip_ready(struct mtd_info *mtd)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+
+	return __raw_readl(ath79_nand->controller + ATH79_NF_STATUS) == 0xff;
+}
+
+static void ath79_nand_select_chip(struct mtd_info *mtd, int chipnr)
+{
+	switch (chipnr) {
+        case -1:
+        case 0:
+		break;
+        default:
+		BUG();
+	}
+}
+
+static uint8_t ath79_nand_read_byte_swap(struct mtd_info *mtd)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+
+	if (ath79_nand->fifo_buf_count) {
+		ath79_nand->fifo_buf >>= 8;
+		ath79_nand->fifo_buf_count--;
+	} else {
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_STATUS) != 1, "read byte swap");
+		ath79_nand->fifo_buf_count = sizeof(uint32_t) - 1;
+		ath79_nand->fifo_buf = __raw_readl(ath79_nand->controller + ATH79_NF_FIFO_DATA);
+	}
+	return (uint8_t)((ath79_nand->fifo_buf) & 0xff);
+}
+
+static uint8_t ath79_nand_read_byte(struct mtd_info *mtd)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+
+	if (ath79_nand->fifo_buf_count) {
+		ath79_nand->fifo_buf <<= 8;
+		ath79_nand->fifo_buf_count--;
+	} else {
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_STATUS) != 1, "read byte");
+		ath79_nand->fifo_buf_count = sizeof(uint32_t) - 1;
+		ath79_nand->fifo_buf = __raw_readl(ath79_nand->controller + ATH79_NF_FIFO_DATA);
+	}
+
+	return (uint8_t)((ath79_nand->fifo_buf >> 24) & 0xff);
+}
+
+static void ath79_nand_read_buf_swap(struct mtd_info *mtd, uint8_t *buf, int left)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+	uint32_t *buf32 = (uint32_t*)buf;
+
+	//read the bulk of the data
+	for (buf32 = (uint32_t*)buf; left > 3; left -=4) {
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_STATUS) != 1, "read buf swap");
+#ifdef __LITTLE_ENDIAN
+		*(buf32++) = be32_to_cpu(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_DATA));
+#elif __BIG_ENDIAN
+		*(buf32++) = le32_to_cpu(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_DATA));
+#else
+#error Unknown endianness
+#endif
+	}
+
+	//any stray bytes at the end
+	for (buf = (uint8_t*)buf32; left > 0; left -=1)
+		*(buf++) = ath79_nand_read_byte_swap(mtd);
+}
+
+static void ath79_nand_read_buf(struct mtd_info *mtd, uint8_t *buf, int left)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+	uint32_t *buf32 = (uint32_t*)buf;
+
+	//read the bulk of the data
+	for (buf32 = (uint32_t*)buf; left > 3; left -=4) {
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_STATUS) == 0, "read buf");
+		*(buf32++) = __raw_readl(ath79_nand->controller + ATH79_NF_FIFO_DATA);
+	}
+
+	//any stray bytes at the end
+	for (buf = (uint8_t*)buf32; left > 0; left -=1)
+		*(buf++) = ath79_nand_read_byte(mtd);
+}
+
+static void ath79_nand_write_buf(struct mtd_info *mtd, const uint8_t *buf, int len)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+	uint32_t *buf32 = (uint32_t*)buf;
+	int left = len;
+
+	//write the bulk of the data
+	for (buf32 = (uint32_t*)buf; left > 3; left -=4) {
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_FIFO_STATUS) == 0, "write buf");
+		__raw_writel(*(buf32++), ath79_nand->controller + ATH79_NF_FIFO_DATA);
+	}
+	BUG_ON(left > 0);
+}
+
+static void ath79_nand_cmd_func_lp(struct mtd_info *mtd, unsigned command, int column, int page_addr)
+{
+	struct ath79_nand *ath79_nand = container_of(mtd, struct ath79_nand, mtd);
+	struct nand_chip *chip = (struct nand_chip *)mtd->priv;
+	uint32_t addr0, addr1;
+	uint32_t pg_size = mtd->writesize + mtd->oobsize;
+
+	column = column == -1 ? 0 : column;
+	page_addr = page_addr == -1 ? 0 : page_addr;
+
+	if (command == NAND_CMD_READOOB) {
+		column += mtd->writesize;
+		command = NAND_CMD_READ0;
+		pg_size = mtd->oobsize;
+	} else {
+		//subtract the offset of the page read/write
+		pg_size -= column;
+	}
+
+	addr0 = column | (page_addr << 16);
+	addr1 = page_addr << 24;
+	__raw_writel(addr0, ath79_nand->controller + ATH79_NF_ADDR0_0);
+	__raw_writel(addr1, ath79_nand->controller + ATH79_NF_ADDR0_1);
+
+
+	__raw_writel(1, ath79_nand->controller + ATH79_NF_FIFO_INIT);
+	__raw_writel(0, ath79_nand->controller + ATH79_NF_FIFO_INIT);
+	ath79_nand->fifo_buf_count = 0; //clear fifo cache
+	chip->read_byte = ath79_nand_read_byte_swap;
+	chip->read_buf = ath79_nand_read_buf_swap;
+	TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_STATUS) & ATH79_NF_CTRL_STAT, "cmd_func fifo init");
+
+	switch(command) {
+        case NAND_CMD_RESET:
+		__raw_writel((command << 8) | ATH79_CMD_SEQ_0, ath79_nand->controller + ATH79_NF_COMMAND);
+		break;
+        case NAND_CMD_READID:
+		__raw_writel(8, ath79_nand->controller + ATH79_NF_PG_SIZE); // 8 byte nand id
+		__raw_writel((command << 8) | ATH79_CMD_SEQ_1,
+			     ath79_nand->controller + ATH79_NF_COMMAND);
+		break;
+        case NAND_CMD_PARAM:
+		__raw_writel(sizeof(struct nand_onfi_params) * 3, ath79_nand->controller + ATH79_NF_PG_SIZE); //is repeated three times
+		__raw_writel((command << 8) | ATH79_CMD_SEQ_2, ath79_nand->controller + ATH79_NF_COMMAND);
+            break;
+        case NAND_CMD_READ0:
+		__raw_writel(pg_size, ath79_nand->controller + ATH79_NF_PG_SIZE);
+		__raw_writel((command << 8) | (NAND_CMD_READSTART << 16) | ATH79_CMD_SEQ_10, ath79_nand->controller + ATH79_NF_COMMAND);
+		chip->read_byte = ath79_nand_read_byte;
+		chip->read_buf = ath79_nand_read_buf;
+            break;
+        case NAND_CMD_STATUS:
+		__raw_writel(4, ath79_nand->controller + ATH79_NF_PG_SIZE);
+		__raw_writel((command << 8) | ATH79_CMD_SEQ_4, ath79_nand->controller + ATH79_NF_COMMAND);
+		TIMEOUT_LOOP(__raw_readl(ath79_nand->controller + ATH79_NF_STATUS) & ATH79_NF_CTRL_STAT, "status cmd");
+		{
+			/*
+			 * the controller puts status output in a different register, so copy
+			 * into the fifo buffer for use by read_byte
+			 */
+			uint32_t tmp = __raw_readl(ath79_nand->controller + ATH79_NF_RD_STATUS);
+			ath79_nand->fifo_buf = tmp << 8;
+			ath79_nand->fifo_buf_count = 3;
+		}
+		break;
+        case NAND_CMD_ERASE1:
+		__raw_writel(addr0 & ~(0x3fffff), ath79_nand->controller + ATH79_NF_ADDR0_0); //make sure it's a block address
+		__raw_writel((command << 8 ) | (NAND_CMD_ERASE2 << 16) | ATH79_CMD_SEQ_14, ath79_nand->controller + ATH79_NF_COMMAND);
+		break;
+        case NAND_CMD_ERASE2:
+		//handled by ERASE1
+		break;
+        case NAND_CMD_SEQIN:
+		__raw_writel(pg_size, ath79_nand->controller + ATH79_NF_PG_SIZE);
+		__raw_writel((command << 8 ) | (NAND_CMD_PAGEPROG << 16) | ATH79_CMD_SEQ_12, ath79_nand->controller + ATH79_NF_COMMAND);
+		break;
+        case NAND_CMD_PAGEPROG:
+		//handled by SEQIN
+		break;
+        default:
+		printk(DRV_NAME ": unknown nand command 0x%x\n", command);
+		return;
+	}
+}
+
+static int __init ath79_nand_probe(struct platform_device *pdev)
+{
+	static const char *part_types[] = { "cmdlinepart", NULL };
+	struct flash_platform_data *plat = pdev->dev.platform_data;
+
+	int err = 0;
+	struct nand_chip *chip;
+	struct mtd_info  *mtd;
+	struct ath79_nand *ath79_nand;
+	int nr_parts = 0;
+	struct mtd_partition *mtd_parts=NULL;
+
+	if (!soc_is_ar934x() && !soc_is_qca955x())
+		return -ENODEV;
+
+	ath79_nand = kzalloc(sizeof(struct ath79_nand), GFP_KERNEL);
+
+	if (!ath79_nand)
+		return -ENOMEM;
+
+	ath79_nand->controller = (void __iomem *)
+		KSEG1ADDR((soc_is_ar934x() ?
+			   AR934X_NAND_BASE :
+			   QCA955X_NAND_BASE));
+
+	ath79_device_reset_set(AR934X_RESET_NAND);
+	udelay(100);
+	ath79_device_reset_clear(AR934X_RESET_NAND);
+	udelay(100);
+
+	mtd = &ath79_nand->mtd;
+	chip = &ath79_nand->chip;
+
+	mtd->owner = THIS_MODULE;
+	mtd->priv = chip;
+	mtd->dev.parent = &pdev->dev;
+	mtd->name = DRV_NAME;
+
+	chip->priv = ath79_nand;
+	chip->dev_ready = ath79_nand_chip_ready;
+	chip->cmdfunc = ath79_nand_cmd_func_lp;
+	chip->read_byte = ath79_nand_read_byte_swap;
+	chip->read_buf = ath79_nand_read_buf_swap;
+	chip->write_buf = ath79_nand_write_buf;
+	chip->select_chip = ath79_nand_select_chip;
+	chip->ecc.mode = NAND_ECC_SOFT_BCH;
+
+	//disable all write protection lines
+	__raw_writel(0xff00, ath79_nand->controller + ATH79_NF_MEM_CTRL);
+
+	if (nand_scan(mtd, 1)) {
+		err = -ENXIO;
+		goto fail;
+	}
+
+	/* Use MTD partition table specified in platform data if available */
+	if (plat) {
+		nr_parts  = plat->nr_parts;
+		mtd_parts = plat->parts;
+	}
+
+	err = mtd_device_parse_register(mtd, part_types, NULL,
+				    mtd_parts, nr_parts);
+	if (err < 0)
+		goto fail_out;
+
+	platform_set_drvdata(pdev, ath79_nand);
+
+	return err;
+
+fail:
+	err = -EIO;
+fail_out:
+	kfree(ath79_nand);
+	return err;
+
+}
+
+static int __exit ath79_nand_remove(struct platform_device *pdev)
+{
+	struct ath79_nand *ath79_nand = platform_get_drvdata(pdev);
+
+	nand_release(&ath79_nand->mtd);
+	kfree(ath79_nand);
+
+	return 0;
+}
+
+static struct platform_driver ath79_nand_driver = {
+	.remove = ath79_nand_remove,
+	.driver = {
+		.name = DRV_NAME,
+		.owner = THIS_MODULE,
+	},
+};
+
+
+static int __init ath79_nand_init(void)
+{
+	return platform_driver_probe(&ath79_nand_driver, ath79_nand_probe);
+}
+
+static void __exit ath79_nand_exit(void)
+{
+	platform_driver_unregister(&ath79_nand_driver);
+}
+
+module_init(ath79_nand_init);
+module_exit(ath79_nand_exit);
+
+MODULE_LICENSE("GPL");
+MODULE_AUTHOR(DRV_AUTHOR);
+MODULE_DESCRIPTION(DRV_DESC);
+MODULE_ALIAS("platform:" DRV_NAME);
--- a/drivers/mtd/nand/Kconfig
+++ b/drivers/mtd/nand/Kconfig
@@ -41,6 +41,13 @@ config MTD_SM_COMMON
 	tristate
 	default n

+config MTD_NAND_ATH79
+	tristate "Atheros on-chip NAND controller"
+	depends on SOC_AR934X || SOC_QCA955X
+	help
+	  This is the NAND controller on Atheros AR9XXX and QCA9XXX
+	  SOCs.
+
 config MTD_NAND_DENALI
         tristate "Support Denali NAND controller"
         depends on HAS_DMA
--- a/drivers/mtd/nand/Makefile
+++ b/drivers/mtd/nand/Makefile
@@ -10,6 +10,7 @@ obj-$(CONFIG_MTD_SM_COMMON) 		+= sm_comm

 obj-$(CONFIG_MTD_NAND_CAFE)		+= cafe_nand.o
 obj-$(CONFIG_MTD_NAND_AMS_DELTA)	+= ams-delta.o
+obj-$(CONFIG_MTD_NAND_ATH79)		+= ath79_nand.o
 obj-$(CONFIG_MTD_NAND_DENALI)		+= denali.o
 obj-$(CONFIG_MTD_NAND_DENALI_PCI)	+= denali_pci.o
 obj-$(CONFIG_MTD_NAND_DENALI_DT)	+= denali_dt.o
--- a/arch/mips/include/asm/mach-ath79/nand.h
+++ b/arch/mips/include/asm/mach-ath79/nand.h
@@ -0,0 +1,145 @@
+#ifndef _ATH79_NAND_H_
+#define _ATH79_NAND_H_
+
+#define ATH79_NF_COMMAND		(0x000u)
+#define ATH79_NF_CTRL			(0x004u)
+#define ATH79_NF_STATUS			(0x008u)
+#define ATH79_NF_INT_MASK		(0x00cu)
+#define ATH79_NF_INT_STATUS		(0x010u)
+#define ATH79_NF_ECC_CTRL		(0x014u)
+#define ATH79_NF_ECC_OFFSET		(0x018u)
+#define ATH79_NF_ADDR0_0		(0x01cu)
+#define ATH79_NF_ADDR1_0		(0x020u)
+#define ATH79_NF_ADDR0_1		(0x024u)
+#define ATH79_NF_ADDR1_1		(0x028u)
+#define ATH79_NF_SPARE_SIZE		(0x030u)
+#define ATH79_NF_PROTECT		(0x038u)
+#define ATH79_NF_LOOKUP_EN		(0x040u)
+#define ATH79_NF_LOOKUP0		(0x044u)
+#define ATH79_NF_LOOKUP1		(0x048u)
+#define ATH79_NF_LOOKUP2		(0x04cu)
+#define ATH79_NF_LOOKUP3		(0x050u)
+#define ATH79_NF_LOOKUP4		(0x054u)
+#define ATH79_NF_LOOKUP5		(0x058u)
+#define ATH79_NF_LOOKUP6		(0x05cu)
+#define ATH79_NF_LOOKUP7		(0x060u)
+#define ATH79_NF_DMA_ADDR		(0x064u)
+#define ATH79_NF_DMA_COUNT		(0x068u)
+#define ATH79_NF_DMA_CTRL		(0x06cu)
+#define ATH79_NF_MEM_CTRL		(0x080u)
+#define ATH79_NF_PG_SIZE		(0x084u)
+#define ATH79_NF_RD_STATUS		(0x088u)
+#define ATH79_NF_TIME_SEQ		(0x08cu)
+#define ATH79_NF_TIMINGS_ASYN		(0x090u)
+#define ATH79_NF_TIMINGS_SYN		(0x094u)
+#define ATH79_NF_FIFO_DATA		(0x098u)
+#define ATH79_NF_TIME_MODE		(0x09cu)
+#define ATH79_NF_DMA_ADDR_OFFSET	(0x0a0u)
+#define ATH79_NF_FIFO_INIT		(0x0b0u)
+#define ATH79_NF_GENERIC_SEQ_CTRL	(0x0b4u)
+#define ATH79_NF_FIFO_STATUS		(0x0b8u)
+
+#define ATH79_NF_CTRL_STAT        (1 << 8)
+
+#define ATH79_NF_TIMING_ASYN	0x11
+#define ATH79_NF_STATUS_OK	0x40	//0xc0
+#define ATH79_NF_RD_STATUS_MASK	0x47	//0xc7
+
+#define ATH79_NF_CTRL_SMALL_BLOCK_EN	(1 << 21)
+
+#define ATH79_NF_CTRL_ADDR_CYCLE1_0	(0 << 18)
+#define ATH79_NF_CTRL_ADDR_CYCLE1_1	(1 << 18)
+#define ATH79_NF_CTRL_ADDR_CYCLE1_2	(2 << 18)
+#define ATH79_NF_CTRL_ADDR_CYCLE1_3	(3 << 18)
+#define ATH79_NF_CTRL_ADDR_CYCLE1_4	(4 << 18)
+#define ATH79_NF_CTRL_ADDR_CYCLE1_5	(5 << 18)
+
+#define ATH79_NF_CTRL_ADDR1_AUTO_INC_EN	(1 << 17)
+#define ATH79_NF_CTRL_ADDR0_AUTO_INC_EN	(1 << 16)
+#define ATH79_NF_CTRL_WORK_MODE_SYNC	(1 << 15)
+#define ATH79_NF_CTRL_PROT_EN		(1 << 14)
+#define ATH79_NF_CTRL_LOOKUP_EN		(1 << 13)
+#define ATH79_NF_CTRL_IO_WIDTH_16BIT	(1 << 12)
+#define ATH79_NF_CTRL_CUSTOM_SIZE_EN	(1 << 11)
+
+#define ATH79_NF_CTRL_PAGE_SIZE_256	(0 <<  8)	/* bytes */
+#define ATH79_NF_CTRL_PAGE_SIZE_512	(1 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_1024	(2 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_2048	(3 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_4096	(4 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_8192	(5 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_16384	(6 <<  8)
+#define ATH79_NF_CTRL_PAGE_SIZE_0		(7 <<  8)
+
+#define ATH79_NF_CTRL_BLOCK_SIZE_32	(0 <<  6)	/* pages */
+#define ATH79_NF_CTRL_BLOCK_SIZE_64	(1 <<  6)
+#define ATH79_NF_CTRL_BLOCK_SIZE_128	(2 <<  6)
+#define ATH79_NF_CTRL_BLOCK_SIZE_256	(3 <<  6)
+
+#define ATH79_NF_CTRL_ECC_EN		(1 <<  5)
+#define ATH79_NF_CTRL_INT_EN		(1 <<  4)
+#define ATH79_NF_CTRL_SPARE_EN		(1 <<  3)
+
+#define ATH79_NF_CTRL_ADDR_CYCLE0_0	(0 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0_1	(1 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0_2	(2 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0_3	(3 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0_4	(4 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0_5	(5 <<  0)
+#define ATH79_NF_CTRL_ADDR_CYCLE0(c)	((c) << 0)
+
+
+#define ATH79_NF_DMA_CTRL_DMA_START	(1 << 7)
+#define ATH79_NF_DMA_CTRL_DMA_DIR_WRITE	(0 << 6)
+#define ATH79_NF_DMA_CTRL_DMA_DIR_READ	(1 << 6)
+#define ATH79_NF_DMA_CTRL_DMA_MODE_SG	(1 << 5)
+/*
+ * 000 - incrementing precise burst of precisely four transfers
+ * 001 - stream burst (address const)
+ * 010 - single transfer (address increment)
+ * 011 - burst of unspecified length (address increment)
+ * 100 - incrementing precise burst of precisely eight transfers
+ * 101 - incrementing precise burst of precisely sixteen transfers
+ */
+#define ATH79_NF_DMA_CTRL_DMA_BURST_0	(0 << 2)
+#define ATH79_NF_DMA_CTRL_DMA_BURST_1	(1 << 2)
+#define ATH79_NF_DMA_CTRL_DMA_BURST_2	(2 << 2)
+#define ATH79_NF_DMA_CTRL_DMA_BURST_3	(3 << 2)
+#define ATH79_NF_DMA_CTRL_DMA_BURST_4	(4 << 2)
+#define ATH79_NF_DMA_CTRL_DMA_BURST_5	(5 << 2)
+#define ATH79_NF_DMA_CTRL_ERR_FLAG	(1 << 1)
+#define ATH79_NF_DMA_CTRL_DMA_READY	(1 << 0)
+
+#define ATH79_NF_ECC_CTRL_ERR_THRESH(x)	((x << 8) & (0x1fu << 8))
+#define ATH79_NF_ECC_CTRL_ECC_CAP(x)	((x << 5) & (0x07u << 5))
+#define ATH79_NF_ECC_CTRL_ECC_2_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(0)
+#define ATH79_NF_ECC_CTRL_ECC_4_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(1)
+#define ATH79_NF_ECC_CTRL_ECC_6_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(2)
+#define ATH79_NF_ECC_CTRL_ECC_8_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(3)
+#define ATH79_NF_ECC_CTRL_ECC_10_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(4)
+#define ATH79_NF_ECC_CTRL_ECC_12_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(5)
+#define ATH79_NF_ECC_CTRL_ECC_14_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(6)
+#define ATH79_NF_ECC_CTRL_ECC_16_BITS	ATH79_NF_ECC_CTRL_ECC_CAP(7)
+
+#define ATH79_NF_ECC_CTRL_ERR_OVER	(1 << 2)
+#define ATH79_NF_ECC_CTRL_ERR_UNCORR	(1 << 1)
+#define ATH79_NF_ECC_CTRL_ERR_CORR	(1 << 0)
+#	define ATH79_NF_ECC_ERROR	(ATH79_NF_ECC_CTRL_ERR_UNCORR | \
+					 ATH79_NF_ECC_CTRL_ERR_OVER)
+
+#define ATH79_NF_CMD_END_INT		(1 << 1)
+
+#define ATH79_NF_HW_ECC		1
+#define ATH79_NF_STATUS_RETRY	1000
+
+#define ATH79_CMD_SEQ_0  0x0
+#define ATH79_CMD_SEQ_1  0x21
+#define ATH79_CMD_SEQ_2  0x22
+#define ATH79_CMD_SEQ_4  0x24
+#define ATH79_CMD_SEQ_7  0x27
+#define ATH79_CMD_SEQ_10 0x2a
+#define ATH79_CMD_SEQ_12 0x0c
+#define ATH79_CMD_SEQ_14 0x0e
+
+#endif //_ATH79_NAND_H_
+
