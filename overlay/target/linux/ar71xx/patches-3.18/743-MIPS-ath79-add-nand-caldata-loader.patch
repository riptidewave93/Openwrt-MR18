--- a/arch/mips/ath79/dev-wmac.c
+++ b/arch/mips/ath79/dev-wmac.c
@@ -17,6 +17,8 @@
 #include <linux/irq.h>
 #include <linux/etherdevice.h>
 #include <linux/platform_device.h>
+#include <linux/mtd/mtd.h>
+#include <linux/mtd/partitions.h>
 #include <linux/ath9k_platform.h>
 #include <linux/gpio.h>

@@ -338,6 +340,40 @@ bool __init ar93xx_wmac_read_mac_address
 	return ret;
 }

+int ath79_get_nand_caldata(struct ath9k_platform_data *pdata,
+					   char *mtd_name, loff_t cal_offset)
+{
+	struct mtd_info *mtd;
+	int retlen, ret, size;
+
+	if (!mtd_name){
+		mtd_name = "caldata";
+	}
+
+	mtd = get_mtd_device_nm(mtd_name);
+	if (IS_ERR(mtd)) {
+		pr_err("%s: Unable to find calibration data, err = %lx\n",
+		       __func__, PTR_ERR(mtd));
+		return -EIO;
+	}
+
+	size = sizeof(pdata->eeprom_data);
+
+	ret = mtd_read(mtd, cal_offset, size, &retlen,
+		       (unsigned char*)pdata->eeprom_data);
+
+	if ((ret < 0) || (retlen != size)) {
+		pr_err("%s: Unable to read caldata from %s, err=%d len=%d\n",
+		       __func__, mtd_name, ret, retlen);
+		return -EIO;
+	} else {
+   pr_info("%s: Device caldata loaded from %s",
+            __func__, mtd_name);
+ }
+
+	return 0;
+}
+
 void __init ath79_wmac_disable_2ghz(void)
 {
 	ath79_wmac_data.disable_2ghz = true;
--- a/arch/mips/ath79/dev-wmac.h
+++ b/arch/mips/ath79/dev-wmac.h
@@ -12,6 +12,7 @@
 #ifndef _ATH79_DEV_WMAC_H
 #define _ATH79_DEV_WMAC_H

+int ath79_get_nand_caldata(struct ath9k_platform_data *pdata, char *mtd_name, loff_t cal_offset);
 void ath79_register_wmac(u8 *cal_data, u8 *mac_addr);
 void ath79_register_wmac_simple(void);
 void ath79_wmac_disable_2ghz(void);
